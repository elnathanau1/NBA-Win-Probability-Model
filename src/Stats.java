import java.util.ArrayList;
import java.util.Arrays;

/**
 * Class that holds statistical analysis methods
 * @author eau
 *
 */
public class Stats {

	/**
	 * compiles a sample of the data with our specific requirements
	 * @param data - ArrayList of Games that our sample of Games will come from
	 * @param scoreDiff - integer representing (homeScore - awayScore)
	 * @param secLeft - integer representing the seconds left in the game
	 * @return ArrayList of ArrayLists of integers representing our sample. Two parallel ArrayLists, first holding the gameId's, second holding whether the team won or lost the respective game (1 = win, 0 = lose)
	 */
	public static ArrayList<ArrayList<Integer>> gatherSample(ArrayList<Game> data, int scoreDiff, int secLeft){
		ArrayList<Integer> gameArray = new ArrayList<Integer>();			//this array holds the gameIds of the games that have had that scoreDiff with that many seconds left
		ArrayList<Integer> winArray = new ArrayList<Integer>();			//this array holds which team won
		for(int i = 0; i < data.size(); i++){
			Game tempGame = data.get(i);
			int index = Methods.getEventIndex(tempGame, secLeft);
			if(scoreDiff == tempGame.events.get(index).scoreDiff){
				gameArray.add(tempGame.events.get(index).gameId);				//add the game to our sample if it qualifies
				winArray.add(tempGame.winner);
			}
			if(scoreDiff == -1 * tempGame.events.get(index).scoreDiff){			//check if the opponent won
				gameArray.add(tempGame.events.get(index).gameId);
				if(tempGame.winner == 1){
					winArray.add(0);
				}
				else{
					winArray.add(1);
				}
			}
		}
		ArrayList<ArrayList<Integer>> sample = new ArrayList<ArrayList<Integer>>();		//put data into a structure
		sample.add(gameArray);
		sample.add(winArray);
		return sample;
	}

	/**
	 * creates a confidence interval for the given sample, storing it in a double array that holds the bounds, p, and n
	 * @param sample - ArrayList of ArrayLists of integers. Typically generated by gatherSample()
	 * @return array of doubles that represent the confidence interval of true proportion of wins from sample. Index 0 holds lower bound, 1 holds upper bound, 2 holds sample proportion, 3 holds population
	 */
	public static double[] makeConfidenceInterval(ArrayList<ArrayList<Integer>> sample){
		double win = 0;
		double n = sample.get(1).size();
		for(int i = 0; i < n; i++){
			if(sample.get(1).get(i) == 1){
				win++;
			}
		}
		double p = win/n;
		double sE = Math.sqrt((p * (1 - p))/n);
		double z = 1.96; 		//for 95% confidence interval


		double[] bounds = new double[4];
		bounds[0] = p - z * sE;		//lower bound
		bounds[1] = p + z * sE;		//upper bound
		bounds[2] = p;				//technically hidden, used as extra data
		bounds[3] = n;
		return bounds;
	}

	/**
	 * Gets the data points to be plotted on the graph
	 * @param data - Arraylist of Games that we will take samples from
	 * @param game - Game that we want to find data points from
	 * @return double[][] that holds data points. each index holds a double[] w/ the respective confidence interval from makeConfidenceInterval()
	 */
	public static double[][] getDataPoints(ArrayList<Game> data, Game game){
		ArrayList<Integer> scoreChanges = new ArrayList<Integer>();			//scoreChanges = list of indices where the score changed
		scoreChanges.add(0);
		int tempScoreDiff = game.events.get(0).scoreDiff;
		for(int i = 1; i < game.events.size(); i++){						//adding each index the score changed
			if(game.events.get(i).scoreDiff != tempScoreDiff){
				tempScoreDiff = game.events.get(i).scoreDiff;
				scoreChanges.add(i);
			}
		}
		double[][] dataPoints = new double[scoreChanges.size() + 1][];
		for(int i = 0; i < scoreChanges.size(); i++){						//fill dataPoints with the bounds of each point
			int tempIndex = scoreChanges.get(i);
			Event tempEvent = game.events.get(tempIndex);
			ArrayList<ArrayList<Integer>> tempSample = gatherSample(data, tempEvent.scoreDiff, tempEvent.secLeft);
			double[] tempBounds = makeConfidenceInterval(tempSample);
			tempBounds = Arrays.copyOf(tempBounds, tempBounds.length + 2);
			tempBounds[tempBounds.length-2] = tempEvent.sequenceId;
			tempBounds[tempBounds.length-1] = tempIndex;
			dataPoints[i] = tempBounds;
		}
		if(game.winner == 1){				//home team won, add a [1, 1, 1] data point
			double[] tempBounds = {1, 1, 1, 1, game.endSequence, game.events.size()-1};
			dataPoints[scoreChanges.size()] = tempBounds;
		}
		else if(game.winner == 0){			//home team lost, add a [0, 0, 0] data point
			double[] tempBounds = {0, 0, 0, 1, game.endSequence, game.events.size()-1};
			dataPoints[scoreChanges.size()] = tempBounds;
		}
		return dataPoints;
	}

	/*	Note: these calculations are merely a conjecture given my basketball intuition and data given (certain things, like free throw 
	 *  percentage and offensive rebounding percentage, can be estimated from data, but would take a large chunk of memory and 
	 *  processing power to acquire). This is an alternative to the other method used to decide whether or not to foul
	 *  
	 * 	Assumptions: 
	 * 	1. Average free throw percentage league-wide is ~75% (http://www.nytimes.com/2009/03/04/sports/basketball/04freethrow.html)
	 *  	a. This number has been pretty standard for a while. In 2015-16, NYK had highest FT% at 0.805, DET had lowest at 0.668. 
	 *  		i. source: http://www.espn.com/nba/statistics/team/_/stat/offense-per-game/sort/freeThrowPct/year/2016/seasontype/2
	 *  	b. Given this percentage, probability an average player makes:
	 *  		i. Both free throws: 0.5625
	 *  		ii. Neither free throw: 0.0625
	 *  		iii. One free throw: 0.375
	 *  			- note: we're ignoring possibility of offensive rebound after a free throw. Both a very small percentage, and data 
	 *  					not found yet
	 *  
	 *  2. Fouling would take away ~1 second from game clock. 
	 *  	a. No research found, but from anecdotal evidence
	 *  
	 *  3. We will be using 2015-16 Shooting trends. This isn't as standard, because 3 point shooting has risen a lot higher over the years.
	 *  	Data for this section from (https://www.teamrankings.com/nba/stat/three-point-pct?date=2016-06-20) 
	 *  	a. In 15-16, 0.2845 of shots were from 3. Note the diff: in 16-17, 0.3167. in 14-15, .2683. 
	 *  		i. Average 3 Point FG% in 15-16 was 0.3521
	 *  	b. In 15-16, 0.7155 of shots were inside arc. 
	 *  		i. Average 2 Point FG% in 15-16 was 0.4900
	 *  	c. For simplicity's sake, assuming wont foul opponent's shot attempt. Not completely unreasonable, as refs seem to not call 
	 *  		fouls at end of games (why is another issue)
	 *  	
	 *  4. Not fouling would result in opponents running down the clock, essentially taking the full 24 seconds
	 *  	a. Again, anecdotal evidence
	 *  
	 *  We will calculate winning % for each of these cases, weighting each interval accordingly. MCI() = makeConfidenceInterval
	 *  	- Case 1: Foul -> both FT made -> mCI(scoreDiff - 2, secLeft - 1)
	 *  		- Weight: 0.5625
	 *  	- Case 2: Foul -> neither FT made -> mCI(scoreDiff, secLeft - 1)
	 *  		- Weight: 0.0625
	 *  	- Case 3: Foul -> one FT made -> mCI(scoreDiff - 1, secLeft - 1)
	 *  		- Weight: 0.375
	 *  	- Case 4: No foul -> 3FGA -> make -> mCI(scoreDiff - 3, secLeft - 24)
	 *  		- Weight: 0.2845 * 0.3521 = 0.10017
	 *  	- Case 5: No foul -> 3FGA -> miss -> mCI(scoreDiff - 0, secLeft - 24)
	 *  		- Weight: 0.2845 * 0.6479 = 0.18433
	 *  	- Case 6: No foul -> 2FGA -> make -> mCI(scoreDiff - 2, secLeft - 24)
	 *  		- Weight: 0.7155 * 0.4900 = 0.350595
	 *  	- Case 6: No foul -> 2FGA -> miss -> mCI(scoreDiff - 0, secLeft - 24)
	 *  		- Weight: 0.7155 * 0.5100 = 0.364905
	 *  	
	 */
	/**
	 * Helps coach decide whether or not to foul at the end of game. 
	 * @param data - ArrayList of Games to take samples from
	 * @param scoreDiff - difference in scores
	 * @param secLeft - seconds left in game clock
	 */
	public static void decideFoul(ArrayList<Game> data, int scoreDiff, int secLeft){
		String clock = Methods.convertSecLeft(secLeft);
		if(scoreDiff > 0){
			System.out.println("Home team up " + scoreDiff + " points with " + clock + " left");
		}
		else if(scoreDiff < 0){
			System.out.println("Home team down " + -1 * scoreDiff + " points with " + clock + " left");
		}
		else{
			System.out.println("Both teams tied with " + clock + " left");
		}
		if(secLeft < 24){			//must foul if secLeft < 24, because you can't just let opponent run out clock
			System.out.println("With less than 24 seconds left, must foul");
			noFoulSample(data, scoreDiff, secLeft);
		}
		else{

			yesFoulSample(data, scoreDiff, secLeft);
			System.out.println("");
			noFoulSample(data, scoreDiff, secLeft);
		}
	}

	/**
	 * helper method for decideFoul()
	 * @param data - data to take sample from
	 * @param scoreDiff - difference in scores
	 * @param secLeft - seconds left in game
	 */
	private static void yesFoulSample(ArrayList<Game> data, int scoreDiff, int secLeft){
		//taken from above
		ArrayList<ArrayList<Integer>> caseOneSample = Stats.gatherSample(data, scoreDiff - 2, secLeft - 1);
		ArrayList<ArrayList<Integer>> caseTwoSample = Stats.gatherSample(data, scoreDiff, secLeft - 1);
		ArrayList<ArrayList<Integer>> caseThreeSample = Stats.gatherSample(data, scoreDiff - 1, secLeft - 1);
		double[] caseOneInterval = Stats.makeConfidenceInterval(caseOneSample);
		double[] caseTwoInterval = Stats.makeConfidenceInterval(caseTwoSample);
		double[] caseThreeInterval = Stats.makeConfidenceInterval(caseThreeSample);
		for(int i = 0; i < 3; i++){
			caseOneInterval[i] *= 0.5625;			//taken from above
			caseTwoInterval[i] *= 0.0625;
			caseThreeInterval[i] *= 0.375;
		}
		double[] finalInterval = new double[4];
		for(int i = 0; i < finalInterval.length; i++){
			finalInterval[i] = caseOneInterval[i] + caseTwoInterval[i] + caseThreeInterval[i];
		}
		System.out.println("If you choose to foul:");
		Print.printConfidenceInterval(finalInterval);
	}

	/**
	 * helper method for decideFoul()
	 * @param data - data to take sample from
	 * @param scoreDiff - difference in scores
	 * @param secLeft - seconds left in game
	 */
	private static void noFoulSample(ArrayList<Game> data, int scoreDiff, int secLeft){
		//taken from above
		ArrayList<ArrayList<Integer>> caseFourSample = Stats.gatherSample(data, scoreDiff - 3, secLeft - 24);
		ArrayList<ArrayList<Integer>> caseFiveSample = Stats.gatherSample(data, scoreDiff, secLeft - 24);
		ArrayList<ArrayList<Integer>> caseSixSample = Stats.gatherSample(data, scoreDiff - 2, secLeft - 24);
		ArrayList<ArrayList<Integer>> caseSevenSample = Stats.gatherSample(data, scoreDiff, secLeft - 24);
		double[] caseFourInterval = Stats.makeConfidenceInterval(caseFourSample);
		double[] caseFiveInterval = Stats.makeConfidenceInterval(caseFiveSample);
		double[] caseSixInterval = Stats.makeConfidenceInterval(caseSixSample);
		double[] caseSevenInterval = Stats.makeConfidenceInterval(caseSevenSample);
		for(int i = 0; i < 3; i++){
			caseFourInterval[i] *= 0.10017;				//taken from above
			caseFiveInterval[i] *= 0.18433;
			caseSixInterval[i] *= 0.350595;
			caseSevenInterval[i] *= 0.364905;
		}
		double[] finalInterval = new double[4];
		for(int i = 0; i < finalInterval.length; i++){
			finalInterval[i] = caseFourInterval[i] + caseFiveInterval[i] + caseSixInterval[i] + caseSevenInterval[i];
		}
		System.out.println("If you choose not to foul:");
		Print.printConfidenceInterval(finalInterval);
	}

	/**
	 * Attempt at gathering a sample of games where teams either fouled/didn't foul
	 * @param data - data to take sample from
	 * @param scoreDiff - difference in scores
	 * @param secLeft - seconds left in game
	 * @return
	 */
	public static ArrayList<ArrayList<Integer>> gatherFoulSample(ArrayList<Game> data, int scoreDiff, int secLeft){
		ArrayList<ArrayList<Integer>> sample = Stats.gatherSample(data, scoreDiff, secLeft);
		sample.add(new ArrayList<Integer>());			//sample.get(2) is whether or not the team that was losing fouled at end of game
		for(int i = 0; i < sample.get(0).size(); i++){
			Game game = Methods.getGameFromId(data, sample.get(0).get(i));
			int fouled = 0;								//0 = didnt foul. 1 = fouled
			for(int j = 0; j < game.events.size(); j++){
				Event event = game.events.get(j);
				if(event.secLeft <= secLeft){		//only important if foul happened after secLeft, otherwise it could be hackashaq from earlier
					if(event.eventDescription.equals("Personal Take")){
						fouled = 1;
					}

				}
			}
			sample.get(2).add(fouled);
		}
		return sample;
	}

	/*
	 * This is not the preferred method of deciding whether or not to foul, it is another method that may or may not provide a different perspective
	 * Warning: This doesnt take into account which team is fouling. This creates problems when you run this when home team is running. Dont.
	 * Potential problems: Doesnt take into account who has possession.
	 */
	/**
	 * Analyze and prints conclusion of foul sample. 
	 * @param sample - sample gathered from gatherFoulSample()
	 * @param scoreDiff - difference in scores
	 * @param secLeft - seconds left in game
	 */
	public static void analyzeFoulSample(ArrayList<ArrayList<Integer>> sample, int scoreDiff, int secLeft){
		//create data structures to hold the two separate samples
		ArrayList<ArrayList<Integer>> noFoul = new ArrayList<ArrayList<Integer>>(2);
		noFoul.add(new ArrayList<Integer>());
		noFoul.add(new ArrayList<Integer>());
		ArrayList<ArrayList<Integer>> yesFoul = new ArrayList<ArrayList<Integer>>(2);
		yesFoul.add(new ArrayList<Integer>());
		yesFoul.add(new ArrayList<Integer>());
		
		//split sample into either noFoul or yesFoul
		for(int i = 0; i < sample.get(0).size(); i++){
			if(sample.get(2).get(i) == 0){
				noFoul.get(0).add(sample.get(0).get(i));
				noFoul.get(1).add(sample.get(1).get(i));
			}
			else{
				yesFoul.get(0).add(sample.get(0).get(i));
				yesFoul.get(1).add(sample.get(1).get(i));
			}
		}
		
		//make confidence intervals for each one
		double[] yesFoulCI = Stats.makeConfidenceInterval(yesFoul);				
		double[] noFoulCI = Stats.makeConfidenceInterval(noFoul);

		//output
		String clock = Methods.convertSecLeft(secLeft);
		if(scoreDiff > 0){
			System.out.println("Home team up " + scoreDiff + " points with " + clock + " left");
		}
		else if(scoreDiff < 0){
			System.out.println("Home team down " + -1 * scoreDiff + " points with " + clock + " left");
		}
		else{
			System.out.println("Both teams tied with " + clock + " left");
		}
		System.out.println("Yes fouled");
		Print.printConfidenceInterval(yesFoulCI);

		System.out.println("\nNo foul");
		Print.printConfidenceInterval(noFoulCI);
	}
}


